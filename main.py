def binary_to_signed_10(x):
    if x[0] == '0':
        return int(x, 2)
    else:
        x = list(x)
        for i in range(0, len(x)):
            if x[i] == '1':
                x[i] = '0'
            else:
                x[i] = '1'
        x = ''.join(x)
        x = int(x, 2) + 1
        return -x


def adr_com(x):
    a_kop = {
        '2': ' AND %s | Логическое умножение',
        '3': '  OR %s | Логическое или',
        '4': ' ADD %s | Сложение',
        '5': ' ADC %s | Сложение с переносом',
        '6': ' SUB %s | Вычитание',
        '7': ' CMP %s | Сравнение',
        '8': 'LOOP %s | Декремент и пропуск',
        '9': '        | Резерв',
        'A': '  LD %s | Загрузка',
        'B': 'SWAM %s | Обмен',
        'C': 'JUMP %s | Переход',
        'D': 'CALL %s | Вызов подпрограммы',
        'E': '  ST %s | Сохранение',
    }
    x_bin = bin(int(x, 16))
    x_bin = x_bin[2:len(x_bin)]
    # Анализ адресации
    m = 'error'
    info = ''
    if x_bin[4] == '0':
        # Прямая абсолютная адресация
        # В мнемонику записываем адрес
        info = '(Прямая абсолютная адресация)'
        m = '0x' + x[1:4].lstrip('0')
    if x_bin[4] == '1':
        if x[1] == 'F':
            # Непосредственная загрузка операнда (записываем в info)
            info = '(Непосредственная загрузка операнда)'
            # В мнемонику записываем операнд
            m = x[2:4]
        elif x[1] == 'E':
            # Прямая относительная адресация (записываем в info)
            info = '(Прямая относительная адресация)'
            # В мнемонику записываем смещение
            offset = binary_to_signed_10(x_bin[8:16])
            if offset > 0:
                m = 'IP+%u' % offset
            else:
                m = 'IP%u' % offset


    print(a_kop.get(x[0]) % m, info, end='')


def bez_adr_com(x):
    b = {
        '0000': 'NOP | Нет операции',
        '0100': 'HLT | Останов',
        '0200': 'CLA | Очистка аккумулятора',
        '0280': 'NOT | Инверсия аккумулятора',
        '0300': 'CLC | Очистка рег. переноса',
        '0380': 'CMC | Инверсия рег. переноса',
        '0400': 'ROL | Циклический сдвиг влево',
        '0480': 'ROR | Циклический сдвиг вправо',
        '0500': 'ASL | Арифметический сдвиг влево',
        '0580': 'ASR | Арифметический сдвиг вправо',
        '0600': 'SXTB | Расширение знака байта',
        '0680': 'SWAB | Обмен ст. и мл. байтов',
        '0700': 'INC | Инкремент',
        '0740': 'DEC | Декремент',
        '0780': 'NEG | Изменение знака'
    }
    print(b.get(x), end='')


def vet_com(x):
    v = {
        'F0': 'BEQ %s | Переход, если равенство',
        'F1': 'BNE %s | Переход, если неравенство',
        'F2': 'BMI %s | Переход, если минус',
        'F3': 'BPL %s | Переход, если плюс',
        'F4': 'BLO/BCS %s | Переход, если ниже/перенос',
        'F5': 'BHIS/BCC %s | Переход, если выше/нет переноса',
        'F6': 'BVS %s | Переход, если переполнение',
        'F7': 'BVC %s | Переход, если нет переполнения',
        'F8': 'BLT %s | Переход, если меньше',
        'F9': 'BGE %s | Переход, если больше или равно',
        'CE': 'BR %s | Безусловный переход (эквивалент JUMP D)',
    }
    print(v.get(x[0:2]) % x[2:4], end='')


with open('input.txt', 'r', encoding='utf-8') as input:
    for c in input:
        c = c.replace('\n', '')
        print(c, '| ', end='')
        if c[0] == "0":
            bez_adr_com(c)
        elif c[0] == "F" or c[0:2] == "CE":
            vet_com(c)
        elif c[0] == "1":
            print("Команды ввода-вывода не поддерживаются!")
        else:
            adr_com(c)
        print()